name: Monitor External Repo and Notify via Bark

on:
  schedule:
    # 每 15 分钟运行一次 (你可以根据需要调整频率)
    # 注意：GitHub Actions 的 schedule 触发器有最小频率限制，过于频繁可能不会精确执行或被临时禁用
    - cron: '*/15 * * * *'
  workflow_dispatch: # 允许手动触发，方便测试

jobs:
  check_and_notify:
    runs-on: ubuntu-latest
    env:
      TARGET_REPO_OWNER: "iterativv"
      TARGET_REPO_NAME: "NostalgiaForInfinity"
      TARGET_BRANCH: "main"  # 改为 main 分支
      LAST_SHA_FILE: "last_seen_sha_for_NostalgiaForInfinity.txt"
      ARTIFACT_NAME: "nostalgiaforinfinity-monitor-state"
      # 添加工作目录环境变量，确保文件路径一致性
      WORKSPACE: "${{ github.workspace }}"

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@17d0e2bd7d51742c71671bd19fa12bdc9d40a3d6 # v2.8.1
        with:
          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs

      - name: Checkout code (to access jq if needed, or for local tools)
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Download last seen SHA
        id: download_artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.WORKSPACE }}
        continue-on-error: true
        # 首次运行时没有 artifact 是正常的，忽略错误
        
      - name: Debug artifact download
        run: |
          echo "Artifact download status: ${{ steps.download_artifact.outcome }}"
          echo "Files in workspace directory:"
          ls -la ${{ env.WORKSPACE }}
          echo "Looking for SHA file:"
          find ${{ env.WORKSPACE }} -name "${{ env.LAST_SHA_FILE }}" -type f || echo "SHA file not found"

      - name: Read last seen SHA from file
        id: get_old_sha
        run: |
          SHA_FILE_PATH="${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}"
          echo "Looking for SHA file at: $SHA_FILE_PATH"
          
          if [ -f "$SHA_FILE_PATH" ]; then
            OLD_SHA=$(cat "$SHA_FILE_PATH")
            # Trim any whitespace
            OLD_SHA=$(echo "$OLD_SHA" | xargs)
            echo "Found last seen SHA: $OLD_SHA"
          else
            OLD_SHA=""
            echo "No last seen SHA file found. This is normal for first run."
          fi
          echo "old_sha=$OLD_SHA" >> $GITHUB_OUTPUT

      - name: Get latest commit SHA from external repository
        id: get_new_sha
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 使用 GITHUB_TOKEN 进行认证，以获得更高的 API 速率限制
        run: |
          API_URL="https://api.github.com/repos/${{ env.TARGET_REPO_OWNER }}/${{ env.TARGET_REPO_NAME }}/commits/${{ env.TARGET_BRANCH }}"
          echo "Fetching from API: $API_URL"
          RESPONSE=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" "$API_URL")

          NEW_SHA=$(echo "$RESPONSE" | jq -r '.sha')
          COMMIT_MSG_FULL=$(echo "$RESPONSE" | jq -r '.commit.message')
          COMMIT_MSG_SUMMARY=$(echo "$COMMIT_MSG_FULL" | head -n 1)
          PUSHER_NAME=$(echo "$RESPONSE" | jq -r '.commit.author.name') # API返回的是 author，不是 pusher
          COMMIT_URL=$(echo "$RESPONSE" | jq -r '.html_url')

          if [ -z "$NEW_SHA" ] || [ "$NEW_SHA" == "null" ]; then
            echo "::error::Could not retrieve new SHA. API Response:"
            echo "$RESPONSE"
            echo "Trying to get default branch..."
            
            # 尝试获取仓库的默认分支
            REPO_INFO=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ env.TARGET_REPO_OWNER }}/${{ env.TARGET_REPO_NAME }}")
            DEFAULT_BRANCH=$(echo "$REPO_INFO" | jq -r '.default_branch')
            
            if [ -n "$DEFAULT_BRANCH" ] && [ "$DEFAULT_BRANCH" != "null" ]; then
              echo "Found default branch: $DEFAULT_BRANCH"
              echo "Trying with default branch..."
              RESPONSE=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ env.TARGET_REPO_OWNER }}/${{ env.TARGET_REPO_NAME }}/commits/$DEFAULT_BRANCH")
              NEW_SHA=$(echo "$RESPONSE" | jq -r '.sha')
              
              if [ -n "$NEW_SHA" ] && [ "$NEW_SHA" != "null" ]; then
                echo "Successfully got SHA from default branch"
                # 更新环境变量
                echo "TARGET_BRANCH=$DEFAULT_BRANCH" >> $GITHUB_ENV
              else
                echo "::error::Failed to get SHA from default branch"
                exit 1
              fi
            else
              echo "::error::Could not determine default branch"
              exit 1
            fi
          fi

          echo "Current latest SHA: $NEW_SHA"
          echo "new_sha=$NEW_SHA" >> $GITHUB_OUTPUT
          echo "commit_msg_summary<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "pusher_name=$PUSHER_NAME" >> $GITHUB_OUTPUT
          echo "commit_url=$COMMIT_URL" >> $GITHUB_OUTPUT

      - name: Debug SHA values
        run: |
          echo "Old SHA: '${{ steps.get_old_sha.outputs.old_sha }}'"
          echo "New SHA: '${{ steps.get_new_sha.outputs.new_sha }}'"
          echo "Are they different? $([ "${{ steps.get_old_sha.outputs.old_sha }}" != "${{ steps.get_new_sha.outputs.new_sha }}" ] && echo "Yes" || echo "No")"
          echo "SHA file exists? $([ -f "${{ env.LAST_SHA_FILE }}" ] && echo "Yes" || echo "No")"
          if [ -f "${{ env.LAST_SHA_FILE }}" ]; then
            echo "SHA file content: $(cat ${{ env.LAST_SHA_FILE }})"
          fi

      - name: Compare SHAs and send Bark notification if new
        # Only send notification if old SHA exists and is different from new SHA
        if: steps.get_old_sha.outputs.old_sha != '' && steps.get_old_sha.outputs.old_sha != steps.get_new_sha.outputs.new_sha
        env:
          BARK_SERVER_URL: ${{ secrets.BARK_URL }} # 从 secrets 获取
          BARK_DEVICE_KEY: ${{ secrets.BARK_DEVICE_KEY }} # 从 secrets 获取
          NEW_SHA: ${{ steps.get_new_sha.outputs.new_sha }}
          COMMIT_MSG_SUMMARY: ${{ steps.get_new_sha.outputs.commit_msg_summary }}
          PUSHER_NAME: ${{ steps.get_new_sha.outputs.pusher_name }}
          COMMIT_URL: ${{ steps.get_new_sha.outputs.commit_url }}
        run: |
          echo "New commit detected. Old SHA: ${{ steps.get_old_sha.outputs.old_sha }}, New SHA: $NEW_SHA"
          echo "Sending Bark notification..."

          if [ -z "$BARK_SERVER_URL" ] || [ -z "$BARK_DEVICE_KEY" ]; then
            echo "Error: BARK_URL or BARK_DEVICE_KEY secret not set."
            exit 1
          fi

          BARK_TITLE_TEXT="GitHub: ${{ env.TARGET_REPO_OWNER }}/${{ env.TARGET_REPO_NAME }} Updated"
          BARK_BODY_TEXT="Branch: ${{ env.TARGET_BRANCH }} by $PUSHER_NAME
          Commit: $(echo "$NEW_SHA" | cut -c1-7)
          Message: $COMMIT_MSG_SUMMARY"

          # URL 编码
          BARK_TITLE_ENCODED=$(printf %s "$BARK_TITLE_TEXT" | jq -sRr @uri)
          BARK_BODY_ENCODED_FOR_PATH=$(printf %s "$BARK_BODY_TEXT" | jq -sRr @uri)
          COMMIT_URL_ENCODED=$(printf %s "$COMMIT_URL" | jq -sRr @uri)

          BARK_REQUEST_URL="${BARK_SERVER_URL}/${BARK_DEVICE_KEY}/${BARK_BODY_ENCODED_FOR_PATH}"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}?title=${BARK_TITLE_ENCODED}"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}&url=${COMMIT_URL_ENCODED}"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}&group=GitHubUpdates"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}&copy=1"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}&isArchive=1"
          # BARK_REQUEST_URL="${BARK_REQUEST_URL}&sound=minuet" # 可选：自定义提示音

          echo "Bark Request URL (DEBUG): ${BARK_REQUEST_URL}"

          HTTP_RESPONSE_CODE=$(curl -X GET "${BARK_REQUEST_URL}" -o /dev/null -s -w "%{http_code}")

          if [ "$HTTP_RESPONSE_CODE" -eq 200 ]; then
            echo "Bark notification sent successfully (HTTP $HTTP_RESPONSE_CODE)."
          else
            echo "Error sending Bark notification (HTTP $HTTP_RESPONSE_CODE)."
            exit 1
          fi

      - name: Update last seen SHA file
        run: |
          # Always update the SHA file with the new SHA, regardless of whether we sent a notification
          # This ensures we have the latest SHA for the next run
          SHA_FILE_PATH="${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}"
          echo "${{ steps.get_new_sha.outputs.new_sha }}" > "$SHA_FILE_PATH"
          echo "Updated $SHA_FILE_PATH with SHA: ${{ steps.get_new_sha.outputs.new_sha }}"
          
          # 检查文件是否存在
          if [ -f "$SHA_FILE_PATH" ]; then
            echo "File exists. Content: $(cat $SHA_FILE_PATH)"
            # Ensure file has proper permissions
            chmod 644 "$SHA_FILE_PATH"
          else
            echo "ERROR: File does not exist after writing!"
            ls -la ${{ env.WORKSPACE }}
            # 尝试在当前目录创建文件作为备份
            echo "${{ steps.get_new_sha.outputs.new_sha }}" > "${{ env.LAST_SHA_FILE }}"
            echo "Created backup file in current directory"
          fi

      - name: Verify file exists before upload
        run: |
          SHA_FILE_PATH="${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}"
          
          if [ -f "$SHA_FILE_PATH" ]; then
            echo "File exists at $SHA_FILE_PATH and ready for upload"
            ls -la "$SHA_FILE_PATH"
            cat "$SHA_FILE_PATH"
          else
            echo "ERROR: File does not exist at $SHA_FILE_PATH before upload!"
            echo "Checking current directory..."
            
            if [ -f "${{ env.LAST_SHA_FILE }}" ]; then
              echo "File exists in current directory, using it"
              cp "${{ env.LAST_SHA_FILE }}" "$SHA_FILE_PATH"
            else
              echo "Creating file with current SHA as fallback"
              echo "${{ steps.get_new_sha.outputs.new_sha }}" > "$SHA_FILE_PATH"
            fi
            
            ls -la "$SHA_FILE_PATH"
          fi

      - name: Upload updated SHA file as artifact
        id: upload_artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}
          retention-days: 90  # 增加保留期限到最大值
          if-no-files-found: error
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Verify artifact upload
        run: |
          echo "Artifact upload status: ${{ steps.upload_artifact.outcome }}"
          echo "If the upload failed, the SHA won't be saved for the next run"
          echo "Artifact ID: ${{ steps.upload_artifact.outputs.artifact-id }}"
          
          # 最终确认
          echo "Final workspace state:"
          ls -la ${{ env.WORKSPACE }}
          echo "SHA file final state:"
          find ${{ env.WORKSPACE }} -name "${{ env.LAST_SHA_FILE }}" -exec ls -la {} \; -exec cat {} \; || echo "SHA file not found"
