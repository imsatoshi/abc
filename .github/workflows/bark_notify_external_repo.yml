name: Monitor External Repo and Notify via Bark

on:
  schedule:
    # 每 15 分钟运行一次 (你可以根据需要调整频率)
    # 注意：GitHub Actions 的 schedule 触发器有最小频率限制，过于频繁可能不会精确执行或被临时禁用
    - cron: '*/15 * * * *'
  workflow_dispatch: # 允许手动触发，方便测试

jobs:
  check_and_notify:
    runs-on: ubuntu-latest
    env:
      TARGET_REPO_OWNER: "iterativv"
      TARGET_REPO_NAME: "NostalgiaForInfinity"
      TARGET_BRANCH: "main"  # 改为 main 分支
      LAST_SHA_FILE: "last_seen_sha.txt"  # 简化文件名
      ARTIFACT_NAME: "repo-monitor-state"  # 简化artifact名称
      # 工作目录环境变量，确保文件路径一致性
      WORKSPACE: "${{ github.workspace }}"

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit # TODO: change to 'egress-policy: block' after couple of runs

      - name: Checkout code (to access jq if needed, or for local tools)
        uses: actions/checkout@v4

      - name: Download last seen SHA
        id: download_artifact
        uses: actions/download-artifact@v3
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.WORKSPACE }}
        continue-on-error: true
        # 首次运行时没有 artifact 是正常的，忽略错误
        
      - name: Debug artifact download
        run: |
          echo "========== 调试信息：Artifact 下载 ==========" 
          echo "Artifact下载状态: ${{ steps.download_artifact.outcome }}"
          echo "工作目录内容:"
          ls -la ${{ env.WORKSPACE }}
          echo "查找SHA文件:"
          find ${{ env.WORKSPACE }} -name "${{ env.LAST_SHA_FILE }}" -type f || echo "SHA文件未找到（首次运行是正常的）"
          
          # 确保SHA文件有正确的权限
          SHA_FILE_PATH="${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}"
          if [ -f "$SHA_FILE_PATH" ]; then
            echo "设置SHA文件权限"
            chmod 644 "$SHA_FILE_PATH"
            echo "SHA文件权限设置后:"
            ls -la "$SHA_FILE_PATH"
            echo "SHA文件内容: $(cat "$SHA_FILE_PATH" || echo '无法读取')"
          fi

      - name: Read last seen SHA from file
        id: get_old_sha
        run: |
          SHA_FILE_PATH="${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}"
          echo "========== 调试信息：读取SHA文件 ==========" 
          echo "查找SHA文件位置: $SHA_FILE_PATH"
          
          if [ -f "$SHA_FILE_PATH" ]; then
            OLD_SHA=$(cat "$SHA_FILE_PATH")
            # 去除空白字符
            OLD_SHA=$(echo "$OLD_SHA" | xargs)
            echo "找到上次记录的SHA: $OLD_SHA"
          else
            OLD_SHA=""
            echo "未找到SHA文件。首次运行时这是正常的，将创建新文件。"
          fi
          
          # 输出到GITHUB_OUTPUT，供后续步骤使用
          echo "old_sha=$OLD_SHA" >> $GITHUB_OUTPUT
          echo "sha_file_path=$SHA_FILE_PATH" >> $GITHUB_OUTPUT

      - name: Get latest commit SHA from external repository
        id: get_new_sha
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # 使用 GITHUB_TOKEN 进行认证，以获得更高的 API 速率限制
        run: |
          API_URL="https://api.github.com/repos/${{ env.TARGET_REPO_OWNER }}/${{ env.TARGET_REPO_NAME }}/commits/${{ env.TARGET_BRANCH }}"
          echo "Fetching from API: $API_URL"
          RESPONSE=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" "$API_URL")

          NEW_SHA=$(echo "$RESPONSE" | jq -r '.sha')
          COMMIT_MSG_FULL=$(echo "$RESPONSE" | jq -r '.commit.message')
          COMMIT_MSG_SUMMARY=$(echo "$COMMIT_MSG_FULL" | head -n 1)
          PUSHER_NAME=$(echo "$RESPONSE" | jq -r '.commit.author.name') # API返回的是 author，不是 pusher
          COMMIT_URL=$(echo "$RESPONSE" | jq -r '.html_url')

          if [ -z "$NEW_SHA" ] || [ "$NEW_SHA" == "null" ]; then
            echo "::error::Could not retrieve new SHA. API Response:"
            echo "$RESPONSE"
            echo "Trying to get default branch..."
            
            # 尝试获取仓库的默认分支
            REPO_INFO=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ env.TARGET_REPO_OWNER }}/${{ env.TARGET_REPO_NAME }}")
            DEFAULT_BRANCH=$(echo "$REPO_INFO" | jq -r '.default_branch')
            
            if [ -n "$DEFAULT_BRANCH" ] && [ "$DEFAULT_BRANCH" != "null" ]; then
              echo "Found default branch: $DEFAULT_BRANCH"
              echo "Trying with default branch..."
              RESPONSE=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/${{ env.TARGET_REPO_OWNER }}/${{ env.TARGET_REPO_NAME }}/commits/$DEFAULT_BRANCH")
              NEW_SHA=$(echo "$RESPONSE" | jq -r '.sha')
              
              if [ -n "$NEW_SHA" ] && [ "$NEW_SHA" != "null" ]; then
                echo "Successfully got SHA from default branch"
                # 更新环境变量
                echo "TARGET_BRANCH=$DEFAULT_BRANCH" >> $GITHUB_ENV
              else
                echo "::error::Failed to get SHA from default branch"
                exit 1
              fi
            else
              echo "::error::Could not determine default branch"
              exit 1
            fi
          fi

          echo "Current latest SHA: $NEW_SHA"
          echo "new_sha=$NEW_SHA" >> $GITHUB_OUTPUT
          echo "commit_msg_summary<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "pusher_name=$PUSHER_NAME" >> $GITHUB_OUTPUT
          echo "commit_url=$COMMIT_URL" >> $GITHUB_OUTPUT

      - name: Debug SHA values
        run: |
          echo "========== 调试信息：SHA比较 ==========" 
          echo "旧SHA: '${{ steps.get_old_sha.outputs.old_sha }}'"
          echo "新SHA: '${{ steps.get_new_sha.outputs.new_sha }}'"
          echo "SHA是否不同? $([ "${{ steps.get_old_sha.outputs.old_sha }}" != "${{ steps.get_new_sha.outputs.new_sha }}" ] && echo "是" || echo "否")"
          
          SHA_FILE_PATH="${{ steps.get_old_sha.outputs.sha_file_path }}"
          echo "SHA文件存在? $([ -f "$SHA_FILE_PATH" ] && echo "是" || echo "否")"
          if [ -f "$SHA_FILE_PATH" ]; then
            echo "SHA文件内容: $(cat $SHA_FILE_PATH)"
          fi

      - name: Compare SHAs and send Bark notification if new
        # 发送通知条件：首次运行(无旧SHA)或SHA有变化
        if: steps.get_old_sha.outputs.old_sha == '' || steps.get_old_sha.outputs.old_sha != steps.get_new_sha.outputs.new_sha
        env:
          BARK_SERVER_URL: ${{ secrets.BARK_URL }} # 从 secrets 获取
          BARK_DEVICE_KEY: ${{ secrets.BARK_DEVICE_KEY }} # 从 secrets 获取
          NEW_SHA: ${{ steps.get_new_sha.outputs.new_sha }}
          COMMIT_MSG_SUMMARY: ${{ steps.get_new_sha.outputs.commit_msg_summary }}
          PUSHER_NAME: ${{ steps.get_new_sha.outputs.pusher_name }}
          COMMIT_URL: ${{ steps.get_new_sha.outputs.commit_url }}
        run: |
          echo "New commit detected. Old SHA: ${{ steps.get_old_sha.outputs.old_sha }}, New SHA: $NEW_SHA"
          echo "Sending Bark notification..."

          if [ -z "$BARK_SERVER_URL" ] || [ -z "$BARK_DEVICE_KEY" ]; then
            echo "Error: BARK_URL or BARK_DEVICE_KEY secret not set."
            exit 1
          fi

          BARK_TITLE_TEXT="GitHub: ${{ env.TARGET_REPO_OWNER }}/${{ env.TARGET_REPO_NAME }} Updated"
          BARK_BODY_TEXT="Branch: ${{ env.TARGET_BRANCH }} by $PUSHER_NAME
          Commit: $(echo "$NEW_SHA" | cut -c1-7)
          Message: $COMMIT_MSG_SUMMARY"

          # URL 编码
          BARK_TITLE_ENCODED=$(printf %s "$BARK_TITLE_TEXT" | jq -sRr @uri)
          BARK_BODY_ENCODED_FOR_PATH=$(printf %s "$BARK_BODY_TEXT" | jq -sRr @uri)
          COMMIT_URL_ENCODED=$(printf %s "$COMMIT_URL" | jq -sRr @uri)

          BARK_REQUEST_URL="${BARK_SERVER_URL}/${BARK_DEVICE_KEY}/${BARK_BODY_ENCODED_FOR_PATH}"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}?title=${BARK_TITLE_ENCODED}"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}&url=${COMMIT_URL_ENCODED}"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}&group=GitHubUpdates"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}&copy=1"
          BARK_REQUEST_URL="${BARK_REQUEST_URL}&isArchive=1"
          # BARK_REQUEST_URL="${BARK_REQUEST_URL}&sound=minuet" # 可选：自定义提示音

          echo "Bark Request URL (DEBUG): ${BARK_REQUEST_URL}"

          HTTP_RESPONSE_CODE=$(curl -X GET "${BARK_REQUEST_URL}" -o /dev/null -s -w "%{http_code}")

          if [ "$HTTP_RESPONSE_CODE" -eq 200 ]; then
            echo "Bark notification sent successfully (HTTP $HTTP_RESPONSE_CODE)."
          else
            echo "Error sending Bark notification (HTTP $HTTP_RESPONSE_CODE)."
            exit 1
          fi

      - name: Update last seen SHA file
        id: update_sha_file
        run: |
          echo "========== 更新SHA文件 ==========" 
          # 始终使用新SHA更新文件，无论是否发送了通知
          # 这确保我们为下次运行保存最新的SHA
          SHA_FILE_PATH="${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}"
          
          # 确保目录存在
          mkdir -p "$(dirname "$SHA_FILE_PATH")"
          
          # 写入新SHA
          echo "${{ steps.get_new_sha.outputs.new_sha }}" > "$SHA_FILE_PATH"
          echo "已更新SHA文件: $SHA_FILE_PATH"
          echo "新SHA值: ${{ steps.get_new_sha.outputs.new_sha }}"
          
          # 验证文件是否成功创建
          if [ -f "$SHA_FILE_PATH" ]; then
            echo "文件已创建。内容: $(cat $SHA_FILE_PATH)"
            # 确保文件有正确的权限
            chmod 644 "$SHA_FILE_PATH"
          else
            echo "错误: 写入后文件不存在!"
            ls -la ${{ env.WORKSPACE }}
            # 尝试在当前目录创建文件作为备份
            echo "${{ steps.get_new_sha.outputs.new_sha }}" > "${{ env.LAST_SHA_FILE }}"
            echo "在当前目录创建了备份文件"
          fi

      - name: Verify file exists before upload
        run: |
          echo "========== 验证文件上传前状态 ==========" 
          SHA_FILE_PATH="${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}"
          
          if [ -f "$SHA_FILE_PATH" ]; then
            echo "文件存在于 $SHA_FILE_PATH 并准备上传"
            ls -la "$SHA_FILE_PATH"
            echo "文件内容: $(cat "$SHA_FILE_PATH")"
          else
            echo "错误: 上传前文件不存在于 $SHA_FILE_PATH!"
            echo "检查当前目录..."
            
            # 确保目录存在
            mkdir -p "$(dirname "$SHA_FILE_PATH")"
            
            if [ -f "${{ env.LAST_SHA_FILE }}" ]; then
              echo "文件存在于当前目录，使用它"
              cp "${{ env.LAST_SHA_FILE }}" "$SHA_FILE_PATH"
            else
              echo "创建包含当前SHA的文件作为备用方案"
              echo "${{ steps.get_new_sha.outputs.new_sha }}" > "$SHA_FILE_PATH"
            fi
            
            echo "创建后的文件状态:"
            ls -la "$SHA_FILE_PATH"
          fi

      - name: Upload updated SHA file as artifact
        id: upload_artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.WORKSPACE }}/${{ env.LAST_SHA_FILE }}
          retention-days: 90  # 增加保留期限到最大值
          if-no-files-found: error  # 改为错误，确保文件存在
          
      - name: Verify artifact upload
        run: |
          echo "========== 验证Artifact上传 ==========" 
          echo "Artifact上传状态: ${{ steps.upload_artifact.outcome }}"
          echo "Artifact ID: ${{ steps.upload_artifact.outputs.artifact-id || '未获取到ID' }}"
          
          # 最终确认
          echo "最终工作目录状态:"
          ls -la ${{ env.WORKSPACE }}
          echo "SHA文件最终状态:"
          find ${{ env.WORKSPACE }} -name "${{ env.LAST_SHA_FILE }}" -exec ls -la {} \; -exec cat {} \; || echo "未找到SHA文件"
